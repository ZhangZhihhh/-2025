# 第二次实验报告

## 2313411 张启鑫

### 练习一：理解first-fit 连续物理内存分配算法

首先我们对 default_pmm.c 文件中出现的 default_init，default_init_memmap ，default_alloc_pages ， default_free_pages 等相关函数函数进行逐个分析。

#### default_init函数--初始化函数

函数内容如下：

```text
static void
default_init(void) {
    list_init(&free_list); 
    nr_free = 0; 
}
```

通过 list_init 函数将空闲链表 free_list 初始化，接着将空闲页的数量 nr_free 设为0，从而完成了对空闲链表管理结构的初始化

#### default_init_memmap函数--初始化内存映射

函数内容如下：

```text
static void
default_init_memmap(struct Page *base, size_t n) {
    assert(n > 0);
    struct Page *p = base;
    for (; p != base + n; p ++) {
        assert(PageReserved(p));
        p->flags = p->property = 0;
        set_page_ref(p, 0);
    }
    base->property = n;
    SetPageProperty(base);
    nr_free += n;
    if (list_empty(&free_list)) {
        list_add(&free_list, &(base->page_link));
    } else {
        list_entry_t* le = &free_list;
        while ((le = list_next(le)) != &free_list) {
            struct Page* page = le2page(le, page_link);
            if (base < page) {
                list_add_before(le, &(base->page_link));
                break;
            } else if (list_next(le) == &free_list) {
                list_add(le, &(base->page_link));
            }
        }
    }
}
```

此函数的作用是将一段连续的物理内存进行初始化并且加入到空闲链表当中。
这个函数将结构体指针 base 和内存块大小 n 作为变量传入， base 指针指向将要被初始化的物理内存块的起始地址。
assert 函数对 n 进行检查（大小不能为负），接着通过 for 循环将这些内存块的标志位和属性值全部清除。接着更改该内存区域头部的块参数，包括属性值和块大小等。
最后通过一些 if、else 语句完成空闲链表的插入：如果链表为空，那么直接进行插入；如果不为空，则根据地址大小比较，找到合适的地方插入

通过上面的两个函数，我们已经完成了对连续的未被引用和分配的空闲物理内存页面的初始化，接下来我们需要通过 default_alloc_pages 函数完成页面的分配

#### default_alloc_pages函数--分配页面

```text
static struct Page *
default_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }
    struct Page *page = NULL;
    list_entry_t *le = &free_list;
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n) {
            page = p;
            break;
        }
    }
    if (page != NULL) {
        list_entry_t* prev = list_prev(&(page->page_link));
        list_del(&(page->page_link));
        if (page->property > n) {
            struct Page *p = page + n;
            p->property = page->property - n;
            SetPageProperty(p);
            list_add(prev, &(p->page_link));
        }
        nr_free -= n;
        ClearPageProperty(page);
    }
    return page;
}
```

首先依旧通过 assert 函数是检验输入的合法性，并通过一条 if 语句对空闲页面的大小进行判断，如果需要分配的内存空间大小大于空闲链表中的空闲页面，则分配失败；反之，说明满足分配条件。
接着，将 page 指针设为 NULL ，并用指针 le 指向空闲链表，方便后面通过 while 循环找到合适的页面。
接着进入到 while 循环内部，循环条件表达式完成了对链表的遍历并限定了退出条件，确保不会一直循环下去（这是个双向链表）。第一行代码 `struct Page *p = le2page(le, page_link);`的作用是让 p 指针指向 page 的头部而不是其内部的链表节点。 if 语句对该 page 块大小与调用需要的内存大小进行比较，从而找到合适的 page 进行分配。
后面的 if 语句则是将分配后剩下的块（如果有）重新链入到链表中，并修改参数，完成分配后的管理。首先通过`list_entry_t* prev = list_prev(&(page->page_link));`定位到前一个节点，并用`list_del`函数删除被分配的 page 块，接着再用一个 if 语句对该 page 块超过分配需求的部分进行拆分，再重新为剩余的 page 设置参数和标志，最终用 list_add 函数将其重新放入链表，等待后续的分配。

完成了页面的分配后，我们已经完成了物理内存分配的大部分内容，但是，还需要考虑进程在使用完这些内存空间后，他们需要重新回到链表，等待其他进程的调用，这就是内存分配的最后一个过程--释放页面！

#### default_free_pages函数--释放页面

```text
static void
default_free_pages(struct Page *base, size_t n) {
    assert(n > 0);
    struct Page *p = base;
    for (; p != base + n; p ++) {
        assert(!PageReserved(p) && !PageProperty(p));
        p->flags = 0;
        set_page_ref(p, 0);
    }
    base->property = n;
    SetPageProperty(base);
    nr_free += n;

    if (list_empty(&free_list)) {
        list_add(&free_list, &(base->page_link));
    } else {
        list_entry_t* le = &free_list;
        while ((le = list_next(le)) != &free_list) {
            struct Page* page = le2page(le, page_link);
            if (base < page) {
                list_add_before(le, &(base->page_link));
                break;
            } else if (list_next(le) == &free_list) {
                list_add(le, &(base->page_link));
            }
        }
    }

    list_entry_t* le = list_prev(&(base->page_link));
    if (le != &free_list) {
        p = le2page(le, page_link);
        if (p + p->property == base) {
            p->property += base->property;
            ClearPageProperty(base);
            list_del(&(base->page_link));
            base = p;
        }
    }

    le = list_next(&(base->page_link));
    if (le != &free_list) {
        p = le2page(le, page_link);
        if (base + base->property == p) {
            base->property += p->property;
            ClearPageProperty(p);
            list_del(&(p->page_link));
        }
    }
}
```

首先，通过`for (; p != base + n; p ++) { assert(!PageReserved(p) && !PageProperty(p)); p->flags = 0; set_page_ref(p, 0); }`对被释放的 page 进行参数设置，清除其所有的标志，assert 语句确保被释放的 page 既不是保留状态也不是空闲状态，将这些操作都完成后，为这个 page 块设置其属性值并重新加入到链表中。后面的两条 if 语句则是合并空闲块的关键步骤：
首先让指针 le 定位到该 page 块在链表中的前一个块的块头，然后用`if (p + p->property == base)`检查两个块的物理地址是否相邻（链表中相邻不一定意味着物理地址中也是相邻的），在确认相邻后，将两个块合并为一块，并清除后面块的属性和标志，更新前面块的属性和标志，删去二者之间的链表指针。这样，就实现了向前合并的操作，向后合并也是此理，这里不再进行分析。
到此，我们对first-fit 连续物理内存分配算法中关键函数的分析就完成了，从上面的分析不难看出，程序在进行物理内存分配的过程大致可以分为三个阶段，分别是：**初始化阶段**、**分配阶段**以及**释放阶段**。
在初始阶段，系统启动时调用 default_init 函数初始化空闲链表， 并通过 default_init_memmap 函数将可用的物理内存区域初始化为空闲块。
在分配阶段，通过 default_alloc_pages 函数扫描空闲链表，找到首个满足大小的空闲块进行分配或分割，并更新空闲页面计数。
在释放阶段，由 default_free_pages 函数将释放的块重新链入空闲链表，并通过前后合并操作将相邻空闲块组合成更大的连续空间。这就是 first-fit 算法进行连续物理内存分配的过程！

#### 算法改进

初始化内存映射的改进
修改后的代码：

```text
static void
default_init_memmap(struct Page *base, size_t n) {
       assert(n > 0);
    struct Page *p = base;
    
    for (; p != base + n; p++) {
        assert(PageReserved(p));
        p->flags = 0;
        set_page_ref(p, 0);
        if (p != base) {
            p->property = 0;
        }
    }
    
    base->property = n;
    SetPageProperty(base);
    nr_free += n;
    list_entry_t *le = &free_list;
    while ((le = list_next(le)) != &free_list) {
        p = le2page(le, page_link);
        if (base < p) {
            break;
        }
    }
    list_add_before(le, &(base->page_link));
}
```

在源代码中通过for循环对每个 page 的属性值赋值为0，退出循环后再为块头赋值，这样存在冗余操作；修改后在循环内通过条件判断，只有非首页才设置property为0，逻辑更清晰。
同时，链表插入操作也存在问题，源代码中需要单独处理空链表情况，且在遍历时需要特殊处理到达链表末尾的情况，因此使用了两种不同的插入函数list_add_before 和 list_add ；修改后可以对空链表和非空链表使用相同的处理逻辑，并利用list_add_before函数的特性：
如果 le 指向链表头，list_add_before 相当于在链表开头插入
如果 le 指向某个节点，list_add_before 在该节点前插入
如果 le 指向链表头（遍历完整个链表），list_add_before 在链表末尾插入
这样减少了条件分支，代码可读性更高。