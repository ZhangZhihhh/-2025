# 操作系统第五次实验报告

### 练习0：填写已有实验

我们需要将LAB3、LAB4中的部分代码移入本次实验的代码中，并做一个优化，主要涉及以下内容：

#### LAB3

trap.c：我们在 `interrupt_handler` 函数中 `case IRQ_S_TIMER` 处按照注释要求加入以下内容：

```
clock_set_next_event();

​    if (++ticks % TICK_NUM == 0) {

​      print_ticks();

​      if (current) {

​        current->need_resched = 1;

​      }

​    }
```

我们用 `clock_set_next_event` 函数设置下一次时钟中断，并在 if 语句中实现计数器自增并对调度条件进行判断：若中断次数达到 `TICK_NUM` ，则标记当前进程（若存在）需要重新调度。

#### LAB4

proc.c：我们对 `alloc_proc `函数内容进行修改，得到如下内容：

```
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->runs = 0;
        proc->kstack = 0;
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        memset(&(proc->context), 0, sizeof(struct context));
        proc->tf = NULL;
        proc->pgdir = 0;
        proc->flags = 0;
        memset(proc->name, 0, PROC_NAME_LEN + 1);
        proc->wait_state = 0;
        proc->cptr = proc->yptr = proc->optr = NULL;
    }
    return proc;
}
```

`alloc_proc`函数用于分配并初始化一个进程控制块结构体，而LAB4中我们已经为该函数完成了初始化工作，在本次实验中，我们又新增了`proc->wait_state = 0 `与`proc->cptr = proc->yptr = proc->optr = NULL`这两行内容，将等待状态与进程关系指针进行了初始化



同时，我们还需要对`proc_run`函数进行修改：

```
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag);
        {
            current = proc;
            lsatp(next->pgdir);
            switch_to(&(prev->context), &(next->context));
        }
        local_intr_restore(intr_flag);
    }
}
```

我们通过`local_intr_save()`保护临界区，用`switch_to(&(prev->context), &(next->context))`执行上下文切换，配合`lsatp()`更新页表，完成了从当前进程到目标进程的完整切换流程



最后，我们还需要修改`do_fork`函数：

```
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    //    1. call alloc_proc to allocate a proc_struct
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }
    // LAB5: set child proc's parent to current process, make sure current process's wait_state is 0
    proc->parent = current;
    assert(current->wait_state == 0);

    //    2. call setup_kstack to allocate a kernel stack for child process
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    //    3. call copy_mm to dup OR share mm according clone_flag
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    //    4. call copy_thread to setup tf & context in proc_struct
    copy_thread(proc, stack, tf);

    //    5. insert proc_struct into hash_list && proc_list, set the relation links of process
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        hash_proc(proc);
        set_links(proc);
    }
    local_intr_restore(intr_flag);

    //    6. call wakeup_proc to make the new child process RUNNABLE
    wakeup_proc(proc);

    //    7. set ret value using child proc's pid
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

我们首先调用`alloc_proc()`分配并初始化进程控制块，然后通过`setup_kstack()`为子进程分配内核栈空间，接着用`copy_mm()`根据`clone_flags`标志决定是共享还是复制父进程的内存空间，再用`copy_thread()`在进程内核栈顶设置陷阱帧并配置内核入口点和栈信息。随后在中断保护的临界区内，通过`get_pid()`分配唯一PID、`hash_proc()`将进程加入哈希表，并插入`proc_list`进程链表。最后调用`wakeup_proc()`将新进程状态设为`PROC_RUNNABLE`，并返回子进程的PID作为函数返回值，完成整个fork操作。

### 练习1: 加载应用程序并执行

要求：请在实验报告中简要说明你的设计实现过程。简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

**代码实现：**

我们在`load_icode`函数中加入如下内容：

```
tf->gpr.sp = USTACKTOP;
tf->epc = elf->e_entry;
tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
```

我们通过`tf->gpr.sp = USTACKTOP`设置用户栈指针，将栈指针指向用户栈顶；接着，通过`tf->epc = elf->e_entry`将异常返回地址设为 ELF 文件的入口点，确保 sret 指令返回时跳转到用户程序起始位置；最后，由`tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE`清除 SPP 位（使 sret 返回到用户态）并设置 SPIE 位（使返回用户态后自动开启中断）。

整个**执行过程**是：当调度器选中该进程并调用 proc_run 切换到 RUNNING 态后，在内核完成进程切换工作并准备返回用户态时，trap_return 函数会从当前进程的 trapframe 中恢复所有寄存器状态（包括 sp、epc 和 sstatus），最后执行 sret 指令，此时 CPU 根据 epc 寄存器跳转到用户程序的入口地址（elf->e_entry），根据 sstatus 的 SPP=0 切换到用户态（S-mode→U-mode），同时因 SPIE=1 而自动开启中断，于是用户程序的第一条指令开始在用户态执行，栈指针 sp 已指向用户栈顶，整个用户进程正式启动运行

### 练习2: 父进程复制自己的内存空间给子进程

**代码实现：**

我们在`copy_range`函数中加入如下内容：

```
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    // copy content by page unit.
    do
    {
        // call get_pte to find process A's pte according to the addr start
        pte_t *ptep = get_pte(from, start, 0), *nptep;
        if (ptep == NULL)
        {
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        // call get_pte to find process B's pte according to the addr start. If
        // pte is NULL, just alloc a PT
        if (*ptep & PTE_V)
        {
            if ((nptep = get_pte(to, start, 1)) == NULL)
            {
                return -E_NO_MEM;
            }
            uint32_t perm = (*ptep & PTE_USER);
            // get page from ptep
            struct Page *page = pte2page(*ptep);
            // alloc a page for process B
            struct Page *npage = alloc_page();
            assert(page != NULL);
            assert(npage != NULL);
            int ret = 0;
            /* LAB5:EXERCISE2 2313411
             * replicate content of page to npage, build the map of phy addr of
             * nage with the linear addr start
             *
             * Some Useful MACROs and DEFINEs, you can use them in below
             * implementation.
             * MACROs or Functions:
             *    page2kva(struct Page *page): return the kernel vritual addr of
             * memory which page managed (SEE pmm.h)
             *    page_insert: build the map of phy addr of an Page with the
             * linear addr la
             *    memcpy: typical memory copy function
             *
             * (1) find src_kvaddr: the kernel virtual address of page
             * (2) find dst_kvaddr: the kernel virtual address of npage
             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
             * (4) build the map of phy addr of  nage with the linear addr start
             */
            void *src_kvaddr = page2kva(page);
            void *dst_kvaddr = page2kva(npage);
            memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
            ret = page_insert(to, npage, start, perm);

            assert(ret == 0);
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
    return 0;
}
```

首先通过`void *src_kvaddr = page2kva(page)`将父进程的物理页面转换为内核虚拟地址，获取源页面的内核虚拟地址；然后用`void *dst_kvaddr = page2kva(npage)`将新分配的子进程物理页面转换为内核虚拟地址，获取目标页面的内核虚拟地址；接着通过`memcpy(dst_kvaddr, src_kvaddr, PGSIZE)`复制内存内容，最后通过`ret = page_insert(to, npage, start, perm);`建立页表的映射

### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

这四个系统调用的执行都遵循相同的用户态与内核态交互模式：当用户程序调用`sys_fork()`等包装函数时，会通过`syscall()`函数将系统调用号和参数加载到寄存器a0-a5中，然后执行`ecall`指令触发CAUSE_USER_ECALL异常，此时硬件自动切换到内核态并跳转到`__alltraps`入口保存所有寄存器到trapframe结构体中，接着`trap()`函数调用`exception_handler()`识别出用户态ecall后将`tf->epc += 4`跳过ecall指令并调用`syscall()`分发函数，该函数从`current->tf->gpr.a0`获取系统调用号并从a1-a5获取参数后调用对应的内核函数如`do_fork()`、`do_execve()`、`do_wait()`或`do_exit()`。在`do_fork()`中，内核态完成`alloc_proc()`分配子进程控制块、`setup_kstack()`分配内核栈、`copy_mm()`调用`dup_mmap()`和`copy_range()`复制父进程的内存空间和页表、`copy_thread()`设置子进程的trapframe（将其a0设为0以区分父子进程）和上下文、`get_pid()`分配PID、`hash_proc()`加入进程表、`wakeup_proc()`设为就绪态，最后返回子进程PID并写入父进程的`tf->gpr.a0`

而`do_execve()`则先通过`lsatp(boot_pgdir_pa)`切换到内核页表，调用`exit_mmap()`、`put_pgdir()`释放旧的用户内存和页表，然后在`load_icode()`中解析ELF格式、通过`mm_map()`和`pgdir_alloc_page()`建立代码段数据段和用户栈的映射、用`memcpy()`复制程序内容，最后设置`tf->gpr.sp = USTACKTOP`、`tf->epc = elf->e_entry`和`tf->status`清除SPP位确保返回用户态时跳转到新程序入口；

而`do_wait()`在内核态调用`find_proc()`查找子进程，如果子进程状态是`PROC_ZOMBIE`则调用`unhash_proc()`、`remove_links()`、`put_kstack()`和`kfree()`回收资源并通过`*code_store = proc->exit_code`将退出码写回用户空间，否则设置`current->state = PROC_SLEEPING`和`current->wait_state = WT_CHILD`后调用`schedule()`主动让出CPU等待子进程退出时调用`wakeup_proc()`唤醒；

而`do_exit()`则在内核态通过`lsatp(boot_pgdir_pa)`切换页表后调用`exit_mmap()`、`put_pgdir()`、`mm_destroy()`释放所有用户内存资源，设置`current->state = PROC_ZOMBIE`和`current->exit_code`，如果父进程的`wait_state == WT_CHILD`则调用`wakeup_proc(proc->parent)`唤醒它，将所有子进程的parent指针改为initproc过继给init进程，最后调用`schedule()`永不返回。

所有这些内核函数执行完毕后，`syscall()`函数将返回值写入`tf->gpr.a0`，然后trap返回流程从trapframe恢复所有寄存器状态，执行`sret`指令根据sstatus的SPP位切换回用户态并跳转到`sepc`（即`tf->epc`）指定的地址继续执行，此时用户程序从`ecall`的下一条指令恢复执行并从a0寄存器获得系统调用的返回值，这样就完成了一次完整的用户态→内核态→用户态的交互过程，其中所有的进程管理、内存分配、页表操作、进程调度等核心工作都在内核态的`do_xxx()`函数中完成，而用户态只负责准备参数、触发异常和接收返回值。

生命周期图：

<img width="1165" height="1931" alt="image-20251214164642448" src="https://github.com/user-attachments/assets/34dd5b65-faf8-4f34-956e-e20d8911e5a3" />
完成所有工作后我们就可以make grade运行我们的代码了，运行结果如下：
<img width="1195" height="930" alt="image" src="https://github.com/user-attachments/assets/af45f662-aa1b-4de7-860c-6ee41bd8aedd" />



