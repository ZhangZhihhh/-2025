# 第四次实验报告
## 练习0
我们需要在 trap.c 中加入此前lab3时钟中断部分的代码，实际上由于本次不需要每隔一秒打印内容，所以我们在 IRQ_S_TIMER 中添加 ```clock_set_next_event(); ```这一行内容即可
## 练习一：分配并初始化一个进程控制块
我们需要完成对 struct proc_struct 结构体的初始化，具体代码如下：
```
        proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->runs = 0;
        proc->kstack = 0;
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        memset(&proc->context, 0, sizeof(struct context));
        proc->tf = NULL;
        proc->pgdir = boot_pgdir_pa;
        proc->flags = 0;
        memset(proc->name, 0, sizeof(proc->name));
        list_init(&proc->list_link);
        list_init(&proc->hash_link);
```
将线程状态设置为未初始化状态，线程ID设为-1来表示此线程暂时还没有 pid ，只有经过 get_pid 后才可以获得真正的 id ，接着线程被CPU运行的次数 proc->runs 、内核栈的栈地址 proc->kstack 等内容全都设置为0。这里需要说明的是，对于```proc->pgdir = boot_pgdir_pa;```是将页表指针设为内核的页目录，这是因为对于内核线程，一开始就会使用内核地址空间；而对于用户进程，后面会通过 copy_mm() 替换成用户态页表，这是 uCore 的标准流程。
### 问题：proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是？
context： 是内核态上下文，用于保存一次进程切换过程中 CPU 寄存器的内容。本实验中用于内核栈上的进程切换。
trapframe：是中断帧结构体，里面保存进程的执行状态。本实验中用于用户态陷入内核时保存全部寄存器，退出内核时恢复用户态。
## 练习二：为新创建的内核线程分配资源
我们需要完成 do_fork 函数中的处理过程，代码如下：
```
    proc = alloc_proc();
    if (!proc)
        goto fork_out;
    if (setup_kstack(proc) < 0)
        goto bad_fork_cleanup_proc;
    if (copy_mm(clone_flags, proc) < 0)
        goto bad_fork_cleanup_kstack;
    copy_thread(proc, stack, tf);
    proc->pid = get_pid();
    proc->parent = current;
    list_add(&proc_list, &proc->list_link);
    hash_proc(proc);
    wakeup_proc(proc);
    nr_process++;
    ret = proc->pid;
```
先调用 alloc_proc 为进程分配一个 PCB ，此时只有一个空白的进程框架，没有实际的上下文信息、栈、页表等内容。接着用 setup_kstack 为子进程分配内核栈，用于异常中断、系统调用时保存 trapframe 。接着
用 copy_mm 和 copy_thread 复制内存管理信息并设置执行上下文。copy_thread 的作用有两个，复制 trapframe。然后设置 PID、父进程指针，并将子进程加入链表和哈希表，用 wakeup_proc 唤醒新进程，最终增加总进程数、返回 PID。
### 问题：ucore是否做到给每个新fork的线程一个唯一的id？
在 uCore 的实现中，每个被成功 fork 出来的线程/进程都能获得一个在 当前所有存在的进程中唯一的 ID ，这个 ID 只是在现在所有存在的进程中唯一，而不是历史中所有存在过的进程中唯一。
首先 pid 由 get_pid() 统一管理，并检查是否冲突，该函数会递增 last_pid 并遍历 proc_list 来检查 ID 是否被使用。而且 uCore 的 fork 流程是串行的，不会出现并发竞争 pid，因此不会有两个并发的 do_fork() 同时调用 get_pid()。
## 练习三：编写proc_run 函数
以下是我们的代码：
```
bool intr_flag;
        local_intr_save(intr_flag);
        struct proc_struct *prev = current;
        current = proc;
        lsatp(proc->pgdir);
        switch_to(&prev->context, &proc->context);
        local_intr_restore(intr_flag);
```
在进行进程切换时，首先使用一个局部变量 intr_flag 保存中断状态，并通过 local_intr_save(intr_flag) 关闭中断以保证上下文切换过程的原子性。随后用 prev = current 记录当前正在运行的旧进程，并将 current = proc 设置为即将运行的新进程。接着调用 lsatp(proc->pgdir) 切换页表，从而让 CPU 使用新进程的地址空间布局。然后通过 switch_to(&prev->context, &proc->context) 完成上下文切换：保存旧进程寄存器并加载新进程寄存器，使 CPU 真正“跳转”到新进程的执行现场。最后使用 local_intr_restore(intr_flag) 恢复之前的中断状态，保证系统在进程切换完成后继续正常响应中断。
### 问题：在本实验的执行过程中，创建且运行了几个内核线程？
创建并运行了 2 个内核线程，分别是 idleproc 空闲进程和 initproc 初始进程

## 扩展练习 Challenge：
### 问题1：说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？
核心结论：通过读写 RISC-V 架构的 sstatus 寄存器控制 SIE 位，实现中断的保存、禁用与恢复，确保临界区操作原子性。
1. 核心依赖与寄存器
依赖文件：sync.h（宏定义）、riscv.h（寄存器操作接口与标志位）。
关键寄存器：sstatus（监督模式状态寄存器），其中 SSTATUS_SIE 位（值为 0x00000002）控制监督模式中断使能。
关键接口：read_csr(sstatus) 读取寄存器值，intr_disable()/intr_enable() 实际控制中断开关（底层通过 csrrc/csrrs 指令操作）。
2. 实现流程
local_intr_save(x)：保存状态并禁用中断
调用 __intr_save() 函数，通过 read_csr(sstatus) 读取当前 sstatus 寄存器值。
检查 SSTATUS_SIE 位是否为 1（判断中断是否处于使能状态）。
若中断使能，则调用 intr_disable() 清除 SSTATUS_SIE 位，禁用中断，并返回 1；否则直接返回 0。
将返回值存入变量 x，记录中断原始状态。
local_intr_restore(x)：恢复中断状态
接收参数 x（中断原始状态记录）。
若 x 为 1（表示原始状态为中断使能），则调用 intr_enable() 置位 SSTATUS_SIE 位，恢复中断；若 x 为 0，则保持中断禁用状态。
3. 核心目的
保护临界区操作（如进程切换、页表修改），避免中断打断导致的数据竞争或状态不一致。
遵循 “禁用 - 操作 - 恢复” 原则，最小化中断关闭时间，减少对系统响应性的影响。

### 问题2：
（一）get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。

核心结论：两段代码相似是因为 RISC-V 不同分页模式（SV32/SV39/SV48）共享 “多级页表索引 + 页表项验证 + 缺页分配” 的统一逻辑，仅索引位宽和级数有差异，代码结构可复用。

1. SV32/SV39/SV48 核心异同

| 特性                | SV32                | SV39                | SV48                |
|---------------------|---------------------|---------------------|---------------------|
| 虚拟地址宽度        | 32 位               | 39 位               | 48 位               |
| 页表级数            | 2 级（PGD→PTE）     | 3 级（PGD→PUD→PTE） | 4 级（PGD→PUD→PMD→PTE） |
| 各级索引位宽        | 10 位（PGD）+10 位（PTE） | 9 位×3（PGD/PUD/PTE） | 9 位×4（PGD/PUD/PMD/PTE） |
| 页大小              | 4KB（固定）         | 4KB（固定）         | 4KB（固定）         |
| 核心逻辑            | 虚拟地址拆分→索引页表→验证有效位→缺页分配 | 与 SV32 一致，仅多一级索引 | 与 SV39 一致，再增加一级索引 |

2. get_pte() 代码结构与分页模式的适配
get_pte() 两段代码分别处理 “一级页表（PDX1）” 和 “二级页表（PDX0）” 的索引、验证与分配：
第一段：通过 PDX1(la) 拆分虚拟地址的一级索引，查找一级页表项（pdep1）。若页表项无效（无 PTE_V 位），则分配物理页并初始化页表。
第二段：通过 PDX0(la) 拆分二级索引，基于一级页表项指向的物理页，查找二级页表项（pdep0）。逻辑与第一段完全一致（验证 PTE_V→分配页表→初始化）。
适配原理：
SV32 仅需 2 级页表，当前代码可直接覆盖。
SV39/SV48 需更多级数，但每级的处理逻辑完全相同（索引→验证→分配），仅需增加对应段代码（如 SV39 增加 PUD 级、SV48 增加 PMD 级），无需改变核心逻辑。
代码中 PDX1/PDX0/PTX 宏已封装不同模式的地址拆分逻辑（如 PDX1SHIFT 对应最高级索引偏移），确保代码兼容性。

（二）目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

当前 “查找 + 分配” 合并的写法适合实验场景的简单需求，但不符合模块化设计原则，复杂场景建议拆分。
1. 合并写法的优势
简化调用：用户无需区分 “仅查找” 和 “查找 + 分配” 场景，调用 get_pte(pgdir, la, create) 即可（create 为 true 时分配，false 时仅查找）。
减少冗余：避免重复编写 “地址拆分→页表索引” 的公共逻辑，代码更简洁。
适配实验需求：实验中虚拟内存采用预映射，页表分配与查找强绑定，合并写法效率更高。
2. 合并写法的劣势
职责不单一：违反 “单一职责原则”，一个函数承担 “查找页表项” 和 “分配页表内存” 两个独立功能，可读性和可维护性差。
灵活性不足：若需仅查找页表项（如 page_remove 函数中判断页表项是否存在），仍需执行分配相关的条件判断，存在不必要的逻辑开销。
可扩展性差：若后续需修改分配逻辑（如更换页表内存分配器），或修改查找逻辑（如增加缓存），会相互影响，风险较高。
3. 拆分建议
建议拆分为两个独立函数：
find_pte(pde_t *pgdir, uintptr_t la)：仅负责查找页表项，返回页表项地址（pte_t *），不存在则返回 NULL，不涉及内存分配。
alloc_and_find_pte(pde_t *pgdir, uintptr_t la)：负责查找页表项，若不存在则分配各级页表内存并初始化，返回页表项地址。
拆分价值：
模块化更清晰，便于后续维护和扩展。
按需调用：仅需查找时调用 find_pte，需分配时调用 alloc_and_find_pte，减少逻辑冗余。
符合操作系统内核的实际设计规范（如 Linux 内核中页表查找与分配分离）。
